---
layout: post
title: "Building a Lisp-Like Language: From Code to Concrete Syntax Tree"
abbrlink: f1ba0121bb264f829147493a021a1428
tags: []
categories:
  - Computer Science
  - Create a language
date: 1741296563700
updated: 1741359730404
---

<!-- toc -->

# Foreword

Creating a programming language has always fascinated me. This is not an expert’s guide but a learning journey, where I explore the fundamental steps of language design by building a simple Lisp-like language from scratch. Instead of just reading theory, I will experiment, make mistakes and refine my understanding along the way.

This article documents my approach to creating a language syntax that look like Lisp (but simpler) and to writing a lexer/parser. By working through these concepts, I aim to develop both a deeper understanding of programming language theory and a working foundation for my own language.

This is more of a learning journey, figuring things out as I go.

# First step, define a language syntax

This language is a Lisp-like programming language designed for educational purposes. It focus on simplicity while retaining essential Lisp features. It adopts Lisp’s parenthesized syntax, functional paradigm and prefix notation. It restricts transitivity in mathematical operations for easier parsing and comprehension. The language includes constructs for defining functions, conditionals, loops, variable assignment and input/output operations.

## Expressions and Parentheses

As with traditional Lisp, all expressions are enclosed within parentheses and follow a prefix notation (Polish notation). This eliminates operator precedence concerns and maintains a consistent parsing structure.

### Function Definition: `define`

Functions are defined using the `define` keyword, followed by the function name, a list of parameters and the function body. The body consists of a single expression, which represents the return value.

#### Example:

```lisp
(define (fact n)
  (if (<= n 1)
      1
      (* n (fact (- n 1)))))
```

### Conditionals: `if`

The `if` expression evaluates a condition and executes one of two possible branches based on the result. The first argument is the condition, the second is the expression executed if the condition is true and the third is the expression executed if the condition is false

#### Example:

```lisp
(if (<= n 1)
    1
    (* n (fact (- n 1))))
```

### Output: `display`

The `display` function prints a value or a string to the output.

#### Example:

```lisp
(display "Hello, World!")
(display (fact 5))
```

### Loops: `while` and `for`

#### `while`

The `while` loop repeats execution of a block as long as the condition is true. The loop body can consist of multiple expressions.

#### Example:

```lisp
(while (< x 10)
  (set x (+ x 1)))
```

#### `for`

The `for` loop iterates over a range of values, with an initial value, an upper bound and an implicit increment of 1.

#### Example:

```lisp
(for (i 0 10)
  (display i))
```

### Constants: `const`

Constants are defined using `const`, which assigns an immutable value to a symbol.

#### Example:

```lisp
(const PI 3.14159)
(define (circle-area r)
  (* (* PI r) r))
(display (circle-area 5))
```

### Variable Assignment: `set`

The `set` expression assigns a new value to an existing variable.

#### Example:

```lisp
(set x 5)
(set x (+ x 1))
```

### User Input: `read`

The `read` function captures user input and assigns it to a variable.

#### Example:

```lisp
(display "Enter a number:")
(set x (read))
(display (* x x))
```

## Syntax Constraints

- Every function call and operation follows the prefix notation.
- Transitivity is not allowed in mathematical expressions. Instead of writing `(* PI r r)`, the proper form is `(* (* PI r) r)`, ensuring a strict and explicit structure.
- Parentheses must always be properly balanced.
- The language does not allow implicit variable declarations; variables must be explicitly initialized before use.

This structured and constrained syntax makes the language easier to parse and implement while reinforcing core computational principles.

***

Work in progress zone

# (WIP) Second step, create a structured representation

The next steps in this process is to transform raw code into a structured representation. This involves two key stages:

1. Lexical analysis (lexing) – breaking the source code into tokens, the fundamental building blocks of syntax.
2. Syntax analysis (parsing) – organizing these tokens into a parse tree, which represents the hierarchical structure of the code according to the language’s grammar.

## Use Case 1 : Function and condition

For this elisp code :

```lisp
(define (fact n)
  (if (<= n 1)
      1
      (* n (fact (- n 1)))))

(display (fact 5))
```

### Parse Tree

```mermaid
graph TD;
    A(("(")) --> B[define]
    B --> C(("("))
    C --> D[fact]
    C --> E[n]
    C --> F((")"))
    C --> G(("("))
    
    G --> H[if]
    H --> I(("("))
    I --> J["≤"]
    I --> K[n]
    I --> L[1]
    I --> M((")"))
    
    H --> N[1]
    
    H --> O(("("))
    O --> P["×"]  
    O --> Q[n]
    O --> R(("("))
    R --> S[fact]
    R --> T(("("))
    T --> U["−"]  
    T --> V[n]
    T --> W[1]
    T --> X((")"))
    R --> Y((")"))
    O --> Z((")"))
    
    G --> AA((")"))
    C --> AB((")"))

    A --> AC(("("))
    AC --> AD[display]
    AD --> AE(("("))
    AE --> AF[fact]
    AE --> AG[5]
    AE --> AH((")"))
    AC --> AI((")"))
```

### Concrete Syntex Tree

```mermaid
graph TD;
    A["Program"] --> B["Body"]
    
    B --> C["FunctionDefinition"]
    C --> D["Head"]
    D --> E["FunctionName"]
    E --> F["fact"]
    D --> G["Parameters"]
    G --> H["n"]
    
    C --> I["Body"]
    I --> J["IfStatement"]
    
    J --> K["Head"]
    K --> L["FunctionName"]
    L --> M["if"]
    
    J --> N["Arguments"]
    N --> O["IfCondition"]
    O --> P["ConditionExpression"]
    P --> Q["FunctionCall"]
    
    Q --> R["Head"]
    R --> S["FunctionName"]
    S --> T["≤"]
    Q --> U["Arguments"]
    U --> V["ParameterReference"]
    V --> W["n"]
    U --> X["Literal"]
    X --> Y["1"]
    
    N --> Z["ThenBranch"]
    Z --> AA["Literal"]
    AA --> AB["1"]
    
    N --> AC["ElseBranch"]
    AC --> AD["Multiplication"]
    
    AD --> AE["Head"]
    AE --> AF["FunctionName"]
    AF --> AG["×"]
    
    AD --> AH["Arguments"]
    AH --> AI["ParameterReference"]
    AI --> AJ["n"]
    
    AH --> AK["FunctionCall"]
    AK --> AL["Head"]
    AL --> AM["FunctionName"]
    AM --> AN["fact"]
    
    AK --> AO["Arguments"]
    AO --> AP["FunctionCall"]
    
    AP --> AQ["Head"]
    AQ --> AR["FunctionName"]
    AR --> AS["−"]
    
    AP --> AT["Arguments"]
    AT --> AU["ParameterReference"]
    AU --> AV["n"]
    AT --> AW["Literal"]
    AW --> AX["1"]
    
    B --> AY["FunctionCall"]
    AY --> AZ["Head"]
    AZ --> BA["FunctionName"]
    BA --> BB["display"]
    
    AY --> BC["Arguments"]
    BC --> BD["FunctionCall"]
    BD --> BE["Head"]
    BE --> BF["FunctionName"]
    BF --> BG["fact"]
    
    BD --> BH["Arguments"]
    BH --> BI["Literal"]
    BI --> BJ["5"]
```
