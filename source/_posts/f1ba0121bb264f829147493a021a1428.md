---
layout: post
title: "Building a Lisp-Like Language: From Code to Concrete Syntax Tree"
abbrlink: f1ba0121bb264f829147493a021a1428
tags: []
categories:
  - Computer Science
  - Create a language
date: 1741296563700
updated: 1741344996456
---

***

## abbrlink: building-a-lisp-like-language-from-code-to-concrete-syntax-tree

<!-- toc -->

# Foreword

Creating a programming language has always fascinated me. This is not an expert’s guide but a learning journey, where I explore the fundamental steps of language design by building a simple Lisp-like language from scratch. Instead of just reading theory, I will experiment, make mistakes, and refine my understanding along the way.

This article documents my approach to writing a lexer and parser, leading to the construction of a Concrete Syntax Tree (CST). By working through these concepts, I aim to develop both a deeper understanding of programming language theory and a working foundation for my own language.

This is more of a learning journey, figuring things out as I go.

# First step, define a language syntax

Todo

# Second step, create a structured representation

The next steps in this process is to transform raw code into a structured representation. This involves two key stages:

1. Lexical analysis (lexing) – breaking the source code into tokens, the fundamental building blocks of syntax.
2. Syntax analysis (parsing) – organizing these tokens into a parse tree, which represents the hierarchical structure of the code according to the language’s grammar.

## Use Case 1 : Function and condition

For this elisp code :

```lisp
(define (fact n)
  (if (<= n 1)
      1
      (* n (fact (- n 1)))))

(display (fact 5))
```

### Parse Tree

```mermaid
graph TD;
    A(("(")) --> B[define]
    B --> C(("("))
    C --> D[fact]
    C --> E[n]
    C --> F((")"))
    C --> G(("("))
    
    G --> H[if]
    H --> I(("("))
    I --> J["≤"]
    I --> K[n]
    I --> L[1]
    I --> M((")"))
    
    H --> N[1]
    
    H --> O(("("))
    O --> P["×"]  
    O --> Q[n]
    O --> R(("("))
    R --> S[fact]
    R --> T(("("))
    T --> U["−"]  
    T --> V[n]
    T --> W[1]
    T --> X((")"))
    R --> Y((")"))
    O --> Z((")"))
    
    G --> AA((")"))
    C --> AB((")"))

    A --> AC(("("))
    AC --> AD[display]
    AD --> AE(("("))
    AE --> AF[fact]
    AE --> AG[5]
    AE --> AH((")"))
    AC --> AI((")"))






```

### Concrete Syntex Tree

```mermaid
graph TD;
    A["Program"] --> B["Body"]
    
    B --> C["FunctionDefinition"]
    C --> D["Head"]
    D --> E["FunctionName"]
    E --> F["fact"]
    D --> G["Parameters"]
    G --> H["n"]
    
    C --> I["Body"]
    I --> J["IfStatement"]
    
    J --> K["Head"]
    K --> L["FunctionName"]
    L --> M["if"]
    
    J --> N["Arguments"]
    N --> O["IfCondition"]
    O --> P["ConditionExpression"]
    P --> Q["FunctionCall"]
    
    Q --> R["Head"]
    R --> S["FunctionName"]
    S --> T["≤"]
    Q --> U["Arguments"]
    U --> V["ParameterReference"]
    V --> W["n"]
    U --> X["Literal"]
    X --> Y["1"]
    
    N --> Z["ThenBranch"]
    Z --> AA["Literal"]
    AA --> AB["1"]
    
    N --> AC["ElseBranch"]
    AC --> AD["Multiplication"]
    
    AD --> AE["Head"]
    AE --> AF["FunctionName"]
    AF --> AG["×"]
    
    AD --> AH["Arguments"]
    AH --> AI["ParameterReference"]
    AI --> AJ["n"]
    
    AH --> AK["FunctionCall"]
    AK --> AL["Head"]
    AL --> AM["FunctionName"]
    AM --> AN["fact"]
    
    AK --> AO["Arguments"]
    AO --> AP["FunctionCall"]
    
    AP --> AQ["Head"]
    AQ --> AR["FunctionName"]
    AR --> AS["−"]
    
    AP --> AT["Arguments"]
    AT --> AU["ParameterReference"]
    AU --> AV["n"]
    AT --> AW["Literal"]
    AW --> AX["1"]
    
    B --> AY["FunctionCall"]
    AY --> AZ["Head"]
    AZ --> BA["FunctionName"]
    BA --> BB["display"]
    
    AY --> BC["Arguments"]
    BC --> BD["FunctionCall"]
    BD --> BE["Head"]
    BE --> BF["FunctionName"]
    BF --> BG["fact"]
    
    BD --> BH["Arguments"]
    BH --> BI["Literal"]
    BI --> BJ["5"]






```
